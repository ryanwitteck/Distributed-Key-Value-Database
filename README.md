# Distributed-Key-Value-Database
Project 6 CS 3700

Followed and Implemented the Raft Protocol: https://raft.github.io/raft.pdf

Our high level approach for this project was to follow the steps given to us in the project description and break them down into its components and implement slowly. We started by defining the message types we wanted to send to other replicas after reading the raft paper and came up with 4 (other than put and get). These were: appendEntries, appendEntriesResponse, voteRequest, and voteRecieved. Essentially they are just a send/response versions of the append entries RPC and vote request RPCs. We also decided to use threading on this assignment, as we hoped it would improve our performance when we were sending and receiving messages. In all honesty, we are not sure how much it did, but we left it in our final implementation in hopes that it did improve performance. We broke down the assigment into various components, the two most important being the election and handling all of the time requirements, and the other was handling each message that was given to us. This helped us designate blocks of the code to one specific task and helped us when implementing.

Challenges we faced were the entire project, this was difficult and took an absurd amount of time. Reading the raft paper multiple times and scanning through every piazza post at least 10 times, and after 10's of  hours of coding, our grade still wont be close to perfect because of the performance standards, which I do not have the time nor the patience to try and figure out how to get that score up before finals. The specific challenges we faced were getting the threading coupled with the election. The election was probably the biggest hurdle, since everything else was just dealing with the json messages and putting and getting things from the data storage.

Some things that are good about our design is our delegation and code separation/organization. I feel that each method serves a single purpose, which makes the code easy to follow. The threading is also a good feature, I feel, as it helps with peformance. I also think that our low number of message types also makes it easier to code and read, as we dont have to keep track of many message types for this implementation. I also think that our data structure was good and that our fields were helpful and concise. 

We tested our code with multiple print statements and running it against the config files. All of our print statements have been commented out and the more trivial ones we used for testing have been deleted, as they were basic and served no purpose anymore other than cluttering the code. Testing this code was not as difficult as other assignments, as using trivial print statements to show the state of each receiver each step of the way was useful in determining where we went wrong. Making sure that our code followed the raft paper also helped in testing, since we knew what needed to happen each step of the way.
